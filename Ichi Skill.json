{"Ichi skill.json":"//% color=\"#0345fc\" weight=10 icon=\"\\uf19d\"\nnamespace IchiRobotic {\n\n    //% group=\"Servo\" weight=62\n    //% weight=100 help=servos/set-angle\n    //% blockId=servoservosetangle block=\"set %servo angle to %degrees=protractorPicker °\"\n    //% degrees.defl=90\n    //% servo.fieldEditor=\"gridpicker\"\n    //% servo.fieldOptions.width=220\n    //% servo.fieldOptions.columns=2\n    //% blockGap=8\n    //% parts=microservo trackArgs=0\n    //% group=\"Positional\"\n    function Servo(degree: number): void {\n        IchiLib.Servo.setAngle(degrees);\n    }\n    //% color=\"#fc0303\"\n    //% blockId=robotbit_motor_run block=\"Motor|%index|speed %speed\"\n    //% group=\"Motor\" weight=59\n    //% speed.min=-255 speed.max=255\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\n    export function MotorRun(index: IchiLib.Motors, speed: number): void {\n        if (!IchiLib.initialized) {\n            IchiLib.initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            IchiLib.setPwm(pp, 0, speed)\n            IchiLib.setPwm(pn, 0, 0)\n        } else {\n            IchiLib.setPwm(pp, 0, 0)\n            IchiLib.setPwm(pn, 0, -speed)\n        }\n    }\n}","IchiLib.ts":"\nnamespace IchiLib {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const MODE2 = 0x01\n    const SUBADR1 = 0x02\n    const SUBADR2 = 0x03\n    const SUBADR3 = 0x04\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n    const LED0_ON_H = 0x07\n    const LED0_OFF_L = 0x08\n    const LED0_OFF_H = 0x09\n    const ALL_LED_ON_L = 0xFA\n    const ALL_LED_ON_H = 0xFB\n    const ALL_LED_OFF_L = 0xFC\n    const ALL_LED_OFF_H = 0xFD\n\n    const STP_CHA_L = 2047\n    const STP_CHA_H = 4095\n\n    const STP_CHB_L = 1\n    const STP_CHB_H = 2047\n\n    const STP_CHC_L = 1023\n    const STP_CHC_H = 3071\n\n    const STP_CHD_L = 3071\n    const STP_CHD_H = 1023\n\n    // HT16K33 commands\n    const HT16K33_ADDRESS = 0x70\n    const HT16K33_BLINK_CMD = 0x80\n    const HT16K33_BLINK_DISPLAYON = 0x01\n    const HT16K33_BLINK_OFF = 0\n    const HT16K33_BLINK_2HZ = 1\n    const HT16K33_BLINK_1HZ = 2\n    const HT16K33_BLINK_HALFHZ = 3\n    const HT16K33_CMD_BRIGHTNESS = 0xE0\n\n    export enum Servos {\n        S1 = 0x01,\n        S2 = 0x02,\n        S3 = 0x03,\n        S4 = 0x04,\n        S5 = 0x05,\n        S6 = 0x06,\n        S7 = 0x07,\n        S8 = 0x08\n    }\n\n    export enum Motors {\n        Phải = 0x1,\n        Trái = 0x4,\n    }\n    export enum Move {\n        Trước = 1,\n        Sau = 2,\n        Trái = 3,\n        Phải = 4,\n    }\n    export enum Steppers {\n        M1 = 0x1,\n        M2 = 0x2\n    }\n\n    export enum SonarVersion {\n        V1 = 0x1,\n        V2 = 0x2\n    }\n\n    export enum Turns {\n        //% blockId=\"T1B4\" block=\"1/4\"\n        T1B4 = 90,\n        //% blockId=\"T1B2\" block=\"1/2\"\n        T1B2 = 180,\n        //% blockId=\"T1B0\" block=\"1\"\n        T1B0 = 360,\n        //% blockId=\"T2B0\" block=\"2\"\n        T2B0 = 720,\n        //% blockId=\"T3B0\" block=\"3\"\n        T3B0 = 1080,\n        //% blockId=\"T4B0\" block=\"4\"\n        T4B0 = 1440,\n        //% blockId=\"T5B0\" block=\"5\"\n        T5B0 = 1800\n    }\n\n    export enum ValueUnit {\n        //% block=\"mm\"\n        Millimeter,\n        //% block=\"cm\"\n        Centimeters\n    }\n\n    export let initialized = false\n    export let initializedMatrix = false\n    export let neoStrip: Strip;\n    export let matBuf = pins.createBuffer(17);\n    export let distanceBuf = 0;\n\n    export function i2cwrite(addr: number, reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    export function i2ccmd(addr: number, value: number) {\n        let buf = pins.createBuffer(1)\n        buf[0] = value\n        pins.i2cWriteBuffer(addr, buf)\n    }\n\n    export function i2cread(addr: number, reg: number) {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\n        return val;\n    }\n\n    export function initPCA9685(): void {\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\n        setFreq(50);\n        for (let idx = 0; idx < 16; idx++) {\n            setPwm(idx, 0, 0);\n        }\n        initialized = true\n    }\n\n    export function setFreq(freq: number): void {\n        // Constrain the frequency\n        let prescaleval = 25000000;\n        prescaleval /= 4096;\n        prescaleval /= freq;\n        prescaleval -= 1;\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\n        control.waitMicros(5000);\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\n    }\n\n    export function setPwm(channel: number, on: number, off: number): void {\n        if (channel < 0 || channel > 15)\n            return;\n        //serial.writeValue(\"ch\", channel)\n        //serial.writeValue(\"on\", on)\n        //serial.writeValue(\"off\", off)\n\n        let buf = pins.createBuffer(5);\n        buf[0] = LED0_ON_L + 4 * channel;\n        buf[1] = on & 0xff;\n        buf[2] = (on >> 8) & 0xff;\n        buf[3] = off & 0xff;\n        buf[4] = (off >> 8) & 0xff;\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\n    }\n\n\n    export function setStepper(index: number, dir: boolean): void {\n        if (index == 1) {\n            if (dir) {\n                setPwm(0, STP_CHA_L, STP_CHA_H);\n                setPwm(2, STP_CHB_L, STP_CHB_H);\n                setPwm(1, STP_CHC_L, STP_CHC_H);\n                setPwm(3, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(3, STP_CHA_L, STP_CHA_H);\n                setPwm(1, STP_CHB_L, STP_CHB_H);\n                setPwm(2, STP_CHC_L, STP_CHC_H);\n                setPwm(0, STP_CHD_L, STP_CHD_H);\n            }\n        } else {\n            if (dir) {\n                setPwm(4, STP_CHA_L, STP_CHA_H);\n                setPwm(6, STP_CHB_L, STP_CHB_H);\n                setPwm(5, STP_CHC_L, STP_CHC_H);\n                setPwm(7, STP_CHD_L, STP_CHD_H);\n            } else {\n                setPwm(7, STP_CHA_L, STP_CHA_H);\n                setPwm(5, STP_CHB_L, STP_CHB_H);\n                setPwm(6, STP_CHC_L, STP_CHC_H);\n                setPwm(4, STP_CHD_L, STP_CHD_H);\n            }\n        }\n    }\n\n    export function stopMotor(index: number) {\n        setPwm((index - 1) * 2, 0, 0);\n        setPwm((index - 1) * 2 + 1, 0, 0);\n    }\n\n    export function matrixInit() {\n        i2ccmd(HT16K33_ADDRESS, 0x21);// turn on oscillator\n        i2ccmd(HT16K33_ADDRESS, HT16K33_BLINK_CMD | HT16K33_BLINK_DISPLAYON | (0 << 1));\n        i2ccmd(HT16K33_ADDRESS, HT16K33_CMD_BRIGHTNESS | 0xF);\n    }\n\n    export function matrixShow() {\n        matBuf[0] = 0x00;\n        pins.i2cWriteBuffer(HT16K33_ADDRESS, matBuf);\n    }\n\n    export function StepperDegree(index: Steppers, degree: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(index, degree > 0);\n        degree = Math.abs(degree);\n        basic.pause(10240 * degree / 360);\n        MotorStopAll()\n    }\n\n\n\n    export function StepperTurn(index: Steppers, turn: Turns): void {\n        let degree = turn;\n        StepperDegree(index, degree);\n    }\n\n\n    export function StepperDual(degree1: number, degree2: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        setStepper(1, degree1 > 0);\n        setStepper(2, degree2 > 0);\n        degree1 = Math.abs(degree1);\n        degree2 = Math.abs(degree2);\n        basic.pause(10240 * Math.min(degree1, degree2) / 360);\n        if (degree1 > degree2) {\n            stopMotor(3); stopMotor(4);\n            basic.pause(10240 * (degree1 - degree2) / 360);\n        } else {\n            stopMotor(1); stopMotor(2);\n            basic.pause(10240 * (degree2 - degree1) / 360);\n        }\n\n        MotorStopAll()\n    }\n\n    export function StpCarMove(distance: number, diameter: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\n        setStepper(1, delay > 0);\n        setStepper(2, delay > 0);\n        delay = Math.abs(delay);\n        basic.pause(delay);\n        MotorStopAll()\n    }\n\n\n    export function StpCarTurn(turn: number, diameter: number, track: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        let delay = 10240 * turn * track / 360 / diameter;\n        setStepper(1, delay < 0);\n        setStepper(2, delay > 0);\n        delay = Math.abs(delay);\n        basic.pause(delay);\n        MotorStopAll()\n    }\n\n    export function MotorRun(index: Motors, speed: number): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            setPwm(pp, 0, speed)\n            setPwm(pn, 0, 0)\n        } else {\n            setPwm(pp, 0, 0)\n            setPwm(pn, 0, -speed)\n        }\n    }\n\n\n\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\n        MotorRun(motor1, speed1);\n        MotorRun(motor2, speed2);\n    }\n\n\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\n        MotorRun(index, speed);\n        basic.pause(delay * 1000);\n        MotorRun(index, 0);\n    }\n\n\n\n    export function MotorStop(index: Motors): void {\n        MotorRun(index, 0);\n    }\n\n    export function MotorStopAll(): void {\n        if (!initialized) {\n            initPCA9685()\n        }\n        for (let idx = 1; idx <= 4; idx++) {\n            stopMotor(idx);\n        }\n    }\n\n    export function MatrixDraw(x: number, y: number): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        x = Math.round(x)\n        y = Math.round(y)\n\n        let idx = y * 2 + Math.idiv(x, 8);\n\n        let tmp = matBuf[idx + 1];\n        tmp |= (1 << (x % 8));\n        matBuf[idx + 1] = tmp;\n    }\n\n    export function MatrixRefresh(): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        matrixShow();\n    }\n\n\n\n    export function MatrixClear(): void {\n        if (!initializedMatrix) {\n            matrixInit();\n            initializedMatrix = true;\n        }\n        for (let i = 0; i < 16; i++) {\n            matBuf[i + 1] = 0;\n        }\n        matrixShow();\n    }\n\n\n    export function RgbUltrasonic(pin: DigitalPin): number {\n        pins.setPull(pin, PinPullMode.PullNone);\n        pins.digitalWritePin(pin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(pin, 0);\n\n        // read pulse\n        let d = pins.pulseIn(pin, PulseValue.High, 25000);\n        let ret = d;\n        // filter timeout spikes\n        if (ret == 0 && distanceBuf != 0) {\n            ret = distanceBuf;\n        }\n        distanceBuf = d;\n\n        return Math.floor(ret * 9 / 6 / 58);\n    }\n\n\n    export function HoleUltrasonic(pin: DigitalPin, unit: ValueUnit): number {\n        pins.setPull(pin, PinPullMode.PullNone);\n        // pins.setPull(pin, PinPullMode.PullDown);\n        pins.digitalWritePin(pin, 0);\n        control.waitMicros(2);\n        pins.digitalWritePin(pin, 1);\n        control.waitMicros(10);\n        pins.digitalWritePin(pin, 0);\n        pins.setPull(pin, PinPullMode.PullUp);\n\n        // read pulse\n        let d = pins.pulseIn(pin, PulseValue.High, 30000);\n        let ret = d;\n        // filter timeout spikes\n        if (ret == 0 && distanceBuf != 0) {\n            ret = distanceBuf;\n        }\n        distanceBuf = d;\n        pins.digitalWritePin(pin, 0);\n        basic.pause(15)\n        if (parseInt(control.hardwareVersion()) == 2) {\n            d = ret * 10 / 58;\n        }\n        else {\n            // return Math.floor(ret / 40 + (ret / 800));\n            d = ret * 15 / 58;\n        }\n        switch (unit) {\n            case ValueUnit.Millimeter: return Math.floor(d)\n            case ValueUnit.Centimeters: return Math.floor(d / 10)\n            default: return d;\n        }\n    }\n\n    export enum NeoPixelColors {\n        //% block=red\n        Red = 0xFF0000,\n        //% block=orange\n        Orange = 0xFFA500,\n        //% block=yellow\n        Yellow = 0xFFFF00,\n        //% block=green\n        Green = 0x00FF00,\n        //% block=blue\n        Blue = 0x0000FF,\n        //% block=indigo\n        Indigo = 0x4b0082,\n        //% block=violet\n        Violet = 0x8a2be2,\n        //% block=purple\n        Purple = 0xFF00FF,\n        //% block=white\n        White = 0xFFFFFF,\n        //% block=black\n        Black = 0x000000\n    }\n\n\n    export enum NeoPixelMode {\n        //% block=\"RGB (GRB format)\"\n        RGB = 1,\n        //% block=\"RGB+W\"\n        RGBW = 2,\n        //% block=\"RGB (RGB format)\"\n        RGB_RGB = 3\n    }\n\n\n    export class Strip {\n        buf: Buffer;\n        pin: DigitalPin;\n        // TODO: encode as bytes instead of 32bit\n        brightness: number;\n        start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _matrixWidth: number; // number of leds in a matrix - if any\n\n        showColor(rgb: number) {\n            rgb = rgb >> 0;\n            this.setAllRGB(rgb);\n            this.show();\n        }\n\n\n        showRainbow(startHue: number = 1, endHue: number = 360) {\n            if (this._length <= 0) return;\n\n            startHue = startHue >> 0;\n            endHue = endHue >> 0;\n            const saturation = 100;\n            const luminance = 50;\n            const steps = this._length;\n            const direction = HueInterpolationDirection.Clockwise;\n\n            //hue\n            const h1 = startHue;\n            const h2 = endHue;\n            const hDistCW = ((h2 + 360) - h1) % 360;\n            const hStepCW = Math.idiv((hDistCW * 100), steps);\n            const hDistCCW = ((h1 + 360) - h2) % 360;\n            const hStepCCW = Math.idiv(-(hDistCCW * 100), steps);\n            let hStep: number;\n            if (direction === HueInterpolationDirection.Clockwise) {\n                hStep = hStepCW;\n            } else if (direction === HueInterpolationDirection.CounterClockwise) {\n                hStep = hStepCCW;\n            } else {\n                hStep = hDistCW < hDistCCW ? hStepCW : hStepCCW;\n            }\n            const h1_100 = h1 * 100; //we multiply by 100 so we keep more accurate results while doing interpolation\n\n            //sat\n            const s1 = saturation;\n            const s2 = saturation;\n            const sDist = s2 - s1;\n            const sStep = Math.idiv(sDist, steps);\n            const s1_100 = s1 * 100;\n\n            //lum\n            const l1 = luminance;\n            const l2 = luminance;\n            const lDist = l2 - l1;\n            const lStep = Math.idiv(lDist, steps);\n            const l1_100 = l1 * 100\n\n            //interpolate\n            if (steps === 1) {\n                this.setPixelColor(0, hsl(h1 + hStep, s1 + sStep, l1 + lStep))\n            } else {\n                this.setPixelColor(0, hsl(startHue, saturation, luminance));\n                for (let i = 1; i < steps - 1; i++) {\n                    const h = Math.idiv((h1_100 + i * hStep), 100) + 360;\n                    const s = Math.idiv((s1_100 + i * sStep), 100);\n                    const l = Math.idiv((l1_100 + i * lStep), 100);\n                    this.setPixelColor(i, hsl(h, s, l));\n                }\n                this.setPixelColor(steps - 1, hsl(endHue, saturation, luminance));\n            }\n            this.show();\n        }\n\n\n        showBarGraph(value: number, high: number): void {\n            if (high <= 0) {\n                this.clear();\n                this.setPixelColor(0, NeoPixelColors.Yellow);\n                this.show();\n                return;\n            }\n\n            value = Math.abs(value);\n            const n = this._length;\n            const n1 = n - 1;\n            let v = Math.idiv((value * n), high);\n            if (v == 0) {\n                this.setPixelColor(0, 0x666600);\n                for (let i = 1; i < n; ++i)\n                    this.setPixelColor(i, 0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i <= v) {\n                        const b = Math.idiv(i * 255, n1);\n                        this.setPixelColor(i, rgb(b, 0, 255 - b));\n                    }\n                    else this.setPixelColor(i, 0);\n                }\n            }\n            this.show();\n        }\n\n\n        setPixelColor(pixeloffset: number, rgb: number): void {\n            this.setPixelRGB(pixeloffset >> 0, rgb >> 0);\n        }\n\n\n        setMatrixWidth(width: number) {\n            this._matrixWidth = Math.min(this._length, width >> 0);\n        }\n\n\n        setMatrixColor(x: number, y: number, rgb: number) {\n            if (this._matrixWidth <= 0) return; // not a matrix, ignore\n            x = x >> 0;\n            y = y >> 0;\n            rgb = rgb >> 0;\n            const cols = Math.idiv(this._length, this._matrixWidth);\n            if (x < 0 || x >= this._matrixWidth || y < 0 || y >= cols) return;\n            let i = x + y * this._matrixWidth;\n            this.setPixelColor(i, rgb);\n        }\n\n\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode === NeoPixelMode.RGBW) {\n                this.setPixelW(pixeloffset >> 0, white >> 0);\n            }\n        }\n\n        show() {\n            // only supported in beta\n            // ws2812b.setBufferMode(this.pin, this._mode);\n            sendBuffer(this.buf, this.pin);\n        }\n\n\n        clear(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.fill(0, this.start * stride, this._length * stride);\n        }\n\n\n        length() {\n            return this._length;\n        }\n\n\n        setBrightness(brightness: number): void {\n            this.brightness = brightness & 0xff;\n        }\n\n\n        easeBrightness(): void {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const br = this.brightness;\n            const buf = this.buf;\n            const end = this.start + this._length;\n            const mid = Math.idiv(this._length, 2);\n            for (let i = this.start; i < end; ++i) {\n                const k = i - this.start;\n                const ledoffset = i * stride;\n                const br = k > mid\n                    ? Math.idiv(255 * (this._length - 1 - k) * (this._length - 1 - k), (mid * mid))\n                    : Math.idiv(255 * k * k, (mid * mid));\n                const r = (buf[ledoffset + 0] * br) >> 8; buf[ledoffset + 0] = r;\n                const g = (buf[ledoffset + 1] * br) >> 8; buf[ledoffset + 1] = g;\n                const b = (buf[ledoffset + 2] * br) >> 8; buf[ledoffset + 2] = b;\n                if (stride == 4) {\n                    const w = (buf[ledoffset + 3] * br) >> 8; buf[ledoffset + 3] = w;\n                }\n            }\n        }\n\n        range(start: number, length: number): Strip {\n            start = start >> 0;\n            length = length >> 0;\n            let strip = new Strip();\n            strip.buf = this.buf;\n            strip.pin = this.pin;\n            strip.brightness = this.brightness;\n            strip.start = this.start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip.start - this.start), length);\n            strip._matrixWidth = 0;\n            strip._mode = this._mode;\n            return strip;\n        }\n\n        shift(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.shift(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n        rotate(offset: number = 1): void {\n            offset = offset >> 0;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            this.buf.rotate(-offset * stride, this.start * stride, this._length * stride)\n        }\n\n\n        setPin(pin: DigitalPin): void {\n            this.pin = pin;\n            pins.digitalWritePin(this.pin, 0);\n            // don't yield to avoid races on initialization\n        }\n\n        power(): number {\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            const end = this.start + this._length;\n            let p = 0;\n            for (let i = this.start; i < end; ++i) {\n                const ledoffset = i * stride;\n                for (let j = 0; j < stride; ++j) {\n                    p += this.buf[i + j];\n                }\n            }\n            return Math.idiv(this.length() * 7, 10) /* 0.7mA per neopixel */\n                + Math.idiv(p * 480, 10000); /* rought approximation */\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            if (this._mode === NeoPixelMode.RGB_RGB) {\n                this.buf[offset + 0] = red;\n                this.buf[offset + 1] = green;\n            } else {\n                this.buf[offset + 0] = green;\n                this.buf[offset + 1] = red;\n            }\n            this.buf[offset + 2] = blue;\n        }\n\n        private setAllRGB(rgb: number) {\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            const br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            const end = this.start + this._length;\n            const stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            for (let i = this.start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n        }\n        private setAllW(white: number) {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            let end = this.start + this._length;\n            for (let i = this.start; i < end; ++i) {\n                let ledoffset = i * 4;\n                buf[ledoffset + 3] = white;\n            }\n        }\n        private setPixelRGB(pixeloffset: number, rgb: number): void {\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            let stride = this._mode === NeoPixelMode.RGBW ? 4 : 3;\n            pixeloffset = (pixeloffset + this.start) * stride;\n\n            let red = unpackR(rgb);\n            let green = unpackG(rgb);\n            let blue = unpackB(rgb);\n\n            let br = this.brightness;\n            if (br < 255) {\n                red = (red * br) >> 8;\n                green = (green * br) >> 8;\n                blue = (blue * br) >> 8;\n            }\n            this.setBufferRGB(pixeloffset, red, green, blue)\n        }\n        private setPixelW(pixeloffset: number, white: number): void {\n            if (this._mode !== NeoPixelMode.RGBW)\n                return;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this.start) * 4;\n\n            let br = this.brightness;\n            if (br < 255) {\n                white = (white * br) >> 8;\n            }\n            let buf = this.buf;\n            buf[pixeloffset + 3] = white;\n        }\n    }\n\n    export function create(pin: DigitalPin, numleds: number, mode: NeoPixelMode): Strip {\n        let strip = new Strip();\n        let stride = mode === NeoPixelMode.RGBW ? 4 : 3;\n        strip.buf = pins.createBuffer(numleds * stride);\n        strip.start = 0;\n        strip._length = numleds;\n        strip._mode = mode || NeoPixelMode.RGB;\n        strip._matrixWidth = 0;\n        strip.setBrightness(128)\n        strip.setPin(pin)\n        return strip;\n    }\n\n    export function rgb(red: number, green: number, blue: number): number {\n        return packRGB(red, green, blue);\n    }\n\n    export function colors(color: NeoPixelColors): number {\n        return color;\n    }\n\n    function packRGB(a: number, b: number, c: number): number {\n        return ((a & 0xFF) << 16) | ((b & 0xFF) << 8) | (c & 0xFF);\n    }\n    function unpackR(rgb: number): number {\n        let r = (rgb >> 16) & 0xFF;\n        return r;\n    }\n    function unpackG(rgb: number): number {\n        let g = (rgb >> 8) & 0xFF;\n        return g;\n    }\n    function unpackB(rgb: number): number {\n        let b = (rgb) & 0xFF;\n        return b;\n    }\n\n    export function hsl(h: number, s: number, l: number): number {\n        h = Math.round(h);\n        s = Math.round(s);\n        l = Math.round(l);\n\n        h = h % 360;\n        s = Math.clamp(0, 99, s);\n        l = Math.clamp(0, 99, l);\n        let c = Math.idiv((((100 - Math.abs(2 * l - 100)) * s) << 8), 10000); //chroma, [0,255]\n        let h1 = Math.idiv(h, 60);//[0,6]\n        let h2 = Math.idiv((h - h1 * 60) * 256, 60);//[0,255]\n        let temp = Math.abs((((h1 % 2) << 8) + h2) - 256);\n        let x = (c * (256 - (temp))) >> 8;//[0,255], second largest component of this color\n        let r$: number;\n        let g$: number;\n        let b$: number;\n        if (h1 == 0) {\n            r$ = c; g$ = x; b$ = 0;\n        } else if (h1 == 1) {\n            r$ = x; g$ = c; b$ = 0;\n        } else if (h1 == 2) {\n            r$ = 0; g$ = c; b$ = x;\n        } else if (h1 == 3) {\n            r$ = 0; g$ = x; b$ = c;\n        } else if (h1 == 4) {\n            r$ = x; g$ = 0; b$ = c;\n        } else if (h1 == 5) {\n            r$ = c; g$ = 0; b$ = x;\n        }\n        let m = Math.idiv((Math.idiv((l * 2 << 8), 100) - c), 2);\n        let r = r$ + m;\n        let g = g$ + m;\n        let b = b$ + m;\n        return packRGB(r, g, b);\n    }\n\n    export enum HueInterpolationDirection {\n        Clockwise,\n        CounterClockwise,\n        Shortest\n    }\n    export function sendBuffer(buf: Buffer, pin: DigitalPin) {\n    }\n\n    export function setBufferMode(pin: DigitalPin, mode: number) {\n\n    }\n\n    export class Servo {\n        private _minAngle: number;\n        private _maxAngle: number;\n        private _stopOnNeutral: boolean;\n        private _angle: number;\n\n        constructor() {\n            this._angle = undefined;\n            this._minAngle = 0;\n            this._maxAngle = 180;\n            this._stopOnNeutral = false;\n        }\n\n        private clampDegrees(degrees: number): number {\n            degrees = degrees | 0;\n            degrees = Math.clamp(this._minAngle, this._maxAngle, degrees);\n            return degrees;\n        }\n\n\n        setAngle(degrees: number) {\n            degrees = this.clampDegrees(degrees);\n            this.internalSetContinuous(false);\n            this._angle = this.internalSetAngle(degrees);\n        }\n\n        get angle() {\n            return this._angle || 90;\n        }\n\n        protected internalSetContinuous(continuous: boolean): void {\n\n        }\n\n        protected internalSetAngle(angle: number): number {\n            return 0;\n        }\n\n\n        run(speed: number): void {\n            const degrees = this.clampDegrees(Math.map(speed, -100, 100, this._minAngle, this._maxAngle));\n            const neutral = (this.maxAngle - this.minAngle) >> 1;\n            this.internalSetContinuous(true);\n            if (this._stopOnNeutral && degrees == neutral)\n                this.stop();\n            else\n                this._angle = this.internalSetAngle(degrees);\n        }\n\n\n\n\n        setPulse(micros: number) {\n            micros = micros | 0;\n            micros = Math.clamp(500, 2500, micros);\n            this.internalSetPulse(micros);\n        }\n\n        protected internalSetPulse(micros: number): void {\n\n        }\n\n\n        stop() {\n            if (this._angle !== undefined)\n                this.internalStop();\n        }\n\n        /**\n         * Gets the minimum angle for the servo\n         */\n        public get minAngle() {\n            return this._minAngle;\n        }\n\n        /**\n         * Gets the maximum angle for the servo\n         */\n        public get maxAngle() {\n            return this._maxAngle;\n        }\n\n\n        public setRange(minAngle: number, maxAngle: number) {\n            this._minAngle = Math.max(0, Math.min(90, minAngle | 0));\n            this._maxAngle = Math.max(90, Math.min(180, maxAngle | 0));\n        }\n\n\n        public setStopOnNeutral(enabled: boolean) {\n            this._stopOnNeutral = enabled;\n        }\n\n        protected internalStop() { }\n    }\n\n    export class PinServo extends Servo {\n        private _pin: PwmOnlyPin;\n\n        constructor(pin: PwmOnlyPin) {\n            super();\n            this._pin = pin;\n        }\n\n        protected internalSetAngle(angle: number): number {\n            this._pin.servoWrite(angle);\n            return angle;\n        }\n\n        protected internalSetContinuous(continuous: boolean): void {\n            this._pin.servoSetContinuous(continuous);\n        }\n\n        protected internalSetPulse(micros: number): void {\n            this._pin.servoSetPulse(micros);\n        }\n\n        protected internalStop() {\n            this._pin.digitalRead();\n            this._pin.setPull(PinPullMode.PullNone);\n        }\n    }\n}\nnamespace IchiLib {\n    //% block=\"servo P0\" fixedInstance whenUsed\n    export const P0 = new IchiLib.PinServo(pins.P0);\n    //% block=\"servo P1\" fixedInstance whenUsed\n    export const P1 = new IchiLib.PinServo(pins.P1);\n    //% block=\"servo P2\" fixedInstance whenUsed\n    export const P2 = new IchiLib.PinServo(pins.P2);\n}\n","IchiRobotic.ts":"//% color=\"#0345fc\" weight=10 icon=\"\\uf19d\"\nnamespace IchiRobotic {\n    //% color=\"#fc0303\"\n    //% blockId=1 block=\"Động cơ |%index|di chuyển với tốc độ %speed\"\n    //% speed.min=-255 speed.max=255\n    export function MotorRun(index: IchiLib.Motors, speed: number): void {\n        if (!IchiLib.initialized) {\n            IchiLib.initPCA9685()\n        }\n        speed = speed * 16; // map 255 to 4096\n        if (speed >= 4096) {\n            speed = 4095\n        }\n        if (speed <= -4096) {\n            speed = -4095\n        }\n        if (index > 4 || index <= 0)\n            return\n        let pp = (index - 1) * 2\n        let pn = (index - 1) * 2 + 1\n        if (speed >= 0) {\n            IchiLib.setPwm(pp, 0, speed)\n            IchiLib.setPwm(pn, 0, 0)\n        } else {\n            IchiLib.setPwm(pp, 0, 0)\n            IchiLib.setPwm(pn, 0, -speed)\n        }\n    }\n    //% color=\"#fc0303\"\n    //% blockId=2 block=\"Động cơ|%index|di chuyển với tốc độ %speed|trong %delay|s\"\n    //% speed.min=-255 speed.max=255\n    export function MotorRunDelay(index: IchiLib.Motors, speed: number, delay: number): void {\n        MotorRun(index, speed);\n        basic.pause(delay * 1000);\n    }\n   \n    //% color=\"#fc0303\"\n    //% blockId=robot_run block=\"Di chuyển về |%index| với tốc độ %speed|trong %delay|s\"\n    //% speed.min=-255 speed.max=255\n    //% index.fieldEditor=\"gridpicker\" index.fieldOptions.columns=4\n    export function RobotRun(index: IchiLib.Move, speed: number, delay: number): void {\n        if (index == 1) {\n            IchiLib.MotorRunDual(\n                IchiLib.Motors.Trái,\n                speed,\n                IchiLib.Motors.Phải,\n                speed\n            );\n        } else if (index == 2) {\n            IchiLib.MotorRunDual(\n                IchiLib.Motors.Trái,\n                -speed,\n                IchiLib.Motors.Phải,\n                speed\n            );\n        } else if (index == 3) {\n            IchiLib.MotorRunDual(\n                IchiLib.Motors.Trái,\n                speed,\n                IchiLib.Motors.Phải,\n                0\n            );\n        } else {\n            IchiLib.MotorRunDual(\n                IchiLib.Motors.Trái,\n                0,\n                IchiLib.Motors.Phải,\n                speed\n            );\n        }\n        basic.pause(delay * 1000);\n        IchiLib.MotorRunDual(\n            IchiLib.Motors.Trái,\n            0,\n            IchiLib.Motors.Phải,\n            0\n        );\n    }\n\n}","README.md":"\n> Mở trang này tại [https://danh0105.github.io/microbit-ichiskill/](https://danh0105.github.io/microbit-ichiskill/)\n\n## Sử dụng tiện ích\n\nKho lưu trữ có thể được thêm vào MakeCode dưới dạng \"khối lệnh mở rộng\".\n\n* mở [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* tìm kiếm **https://github.com/danh0105/microbit-ichiskill** và nhập\n\n## Sửa dự án\n\nĐể chỉnh sửa kho lưu trữ trong MakeCode.\n\n* mở [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* dán **https://github.com/danh0105/microbit-ichiskill** và nhấp vào nhập\n\n#### Siêu dữ liệu (được sử dụng để tìm kiếm, kết xuất)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","main.py":"# ...","main.ts":"\n","pxt.json":"{\n    \"name\": \"Ichi Skill\",\n    \"version\": \"0.0.2\",\n    \"description\": \"Công ty cổ phần giáo dục khoa học công nghệ\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"Ichi skill.json\",\n        \"IchiLib.ts\",\n        \"IchiRobotic.ts\",\n        \"tutorial-info-cache.json\",\n        \"main.py\",\n        \"main.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"6.0.28\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"icon\": \"https://pxt.azureedge.net/blob/7ae30013e6ae7975b5686d614d701fa1e8821768/static/libs/servo.png\"\n}\n","test.ts":"// .\n","tutorial-info-cache.json":"{\"https://github.com/danh0105/microbit-ichiskill\":{\"snippetBlocks\":{},\"usedBlocks\":{},\"highlightBlocks\":{},\"hash\":\"1addcb45ade6ffdca58d2e2c2f1b1c582ae9dae9bd392132a94997e42a82bf23\"}}"}